// Fun√ß√µes de valida√ß√£o e normaliza√ß√£o de c√≥digos de barras
function calcularDigitoVerificador(codigo) {
    let soma = 0;
    for (let i = 0; i < codigo.length; i++) {
        soma += parseInt(codigo[i]) * (i % 2 === 0 ? 1 : 3);
    }
    return (10 - (soma % 10)) % 10;
}

// Valida o formato do c√≥digo de barras
function validarCodigoBarras(codigo) {
    // Remove todos os caracteres n√£o num√©ricos
    const codigoLimpo = codigo.replace(/\D/g, '');

    // Verifica o comprimento
    if (codigoLimpo.length < 8 || codigoLimpo.length > 13) {
        return { valido: false, mensagem: 'O c√≥digo deve ter entre 8 e 13 d√≠gitos' };
    }

    // Verifica se s√£o apenas n√∫meros
    if (!/^\d+$/.test(codigoLimpo)) {
        return { valido: false, mensagem: 'O c√≥digo deve conter apenas n√∫meros' };
    }

    return {
        valido: true,
        codigo: codigoLimpo,
        tipo: identificarTipoCodigo(codigoLimpo)
    };
}

// Identifica o tipo de c√≥digo de barras
function identificarTipoCodigo(codigo) {
    const len = codigo.length;

    // ISBN-10 (10 d√≠gitos)
    if (len === 10) return 'ISBN-10';

    // UPC-A (12 d√≠gitos)
    if (len === 12) return 'UPC-A';

    // EAN-13 (13 d√≠gitos)
    if (len === 13) {
        // Verifica se √© um ISBN-13 (come√ßa com 978 ou 979)
        if (codigo.startsWith('978') || codigo.startsWith('979')) {
            return 'ISBN-13';
        }
        return 'EAN-13';
    }

    // EAN-8 (8 d√≠gitos)
    if (len === 8) return 'EAN-8';

    // Outros formatos
    return `C√≥digo de ${len} d√≠gitos`;
}

// Converte entre formatos de c√≥digo de barras
function converterCodigo(codigo, formatoAlvo) {
    const { tipo } = validarCodigoBarras(codigo);

    // Se j√° est√° no formato desejado, retorna o c√≥digo original
    if (tipo === formatoAlvo) return codigo;

    // Convers√µes suportadas
    if (formatoAlvo === 'EAN-13') {
        if (tipo === 'UPC-A') {
            return '0' + codigo; // Adiciona um zero no in√≠cio
        }
    } else if (formatoAlvo === 'UPC-A') {
        if (tipo === 'EAN-13' && codigo.startsWith('0')) {
            return codigo.substring(1); // Remove o primeiro zero
        }
    } else if (formatoAlvo === 'ISBN-13' && tipo === 'ISBN-10') {
        // Converte ISBN-10 para ISBN-13
        const isbnBase = '978' + codigo.substring(0, 9);
        const digitoVerificador = calcularDigitoVerificador(isbnBase);
        return isbnBase + digitoVerificador;
    } else if (formatoAlvo === 'ISBN-10' && tipo === 'ISBN-13' &&
              (codigo.startsWith('978') || codigo.startsWith('979'))) {
        // Converte ISBN-13 para ISBN-10 (apenas para c√≥digos que come√ßam com 978/979)
        const isbnBase = codigo.substring(3, 12);
        let soma = 0;
        for (let i = 0; i < 9; i++) {
            soma += parseInt(isbnBase[i]) * (10 - i);
        }
        const digito = (11 - (soma % 11)) % 11;
        return isbnBase + (digito === 10 ? 'X' : digito);
    }

    // Se n√£o houver convers√£o suportada, retorna o c√≥digo original
    return codigo;
}

// Normaliza um c√≥digo de barras para o formato mais comum (EAN-13 quando poss√≠vel)
function normalizarCodigo(codigo) {
    const { tipo } = validarCodigoBarras(codigo);

    switch (tipo) {
        case 'UPC-A':
            return '0' + codigo; // Converte para EAN-13
        case 'ISBN-10':
            return converterCodigo(codigo, 'ISBN-13');
        default:
            return codigo;
    }
}

// Fun√ß√£o para converter entre formatos e atualizar a busca
function converterEAtualizar(codigoAtual, novoFormato) {
    event.preventDefault();
    const novoCodigo = converterCodigo(codigoAtual, novoFormato);
    if (novoCodigo !== codigoAtual) {
        document.getElementById('searchBarcode').value = novoCodigo;
        buscarProduto();
    }
    return false;
}

function gerarCodigos() {
    let countryCode = document.getElementById("countrySelect").value;
    let codigoBase = document.getElementById("codigoBase").value.replace(/\D/g, "");
    if (codigoBase.length < 1 || codigoBase.length > 8) {
        alert("‚úèÔ∏è Insira um c√≥digo do produto com at√© 8 d√≠gitos.");
        return;
    }
    let base = countryCode + codigoBase.padStart(8, "0");
    let lista = document.getElementById("listaCodigos");
    lista.innerHTML = "";
    for (let i = 0; i < 10; i++) {
        let codigo12 = base.slice(0, 11) + i.toString();
        let dv = calcularDigitoVerificador(codigo12);
        let codigoCompleto = codigo12 + dv;
        let li = document.createElement("li");
        li.textContent = codigoCompleto;
        lista.appendChild(li);
    }
}

async function buscarProduto() {
    let codigoInput = document.getElementById("searchBarcode").value.trim();
    let resultado = document.getElementById("searchResult");

    // Valida o c√≥digo de barras
    const validacao = validarCodigoBarras(codigoInput);
    if (!validacao.valido) {
        resultado.innerHTML = `<p class='error'>‚úèÔ∏è ${validacao.mensagem || 'C√≥digo de barras inv√°lido'}</p>`;
        return;
    }

    // Normaliza o c√≥digo para o formato mais comum
    const codigo = normalizarCodigo(validacao.codigo);
    const tipoCodigo = identificarTipoCodigo(codigo);

    // Atualiza a interface para mostrar o tipo de c√≥digo detectado
    document.getElementById('barcode-type').textContent = `Tipo: ${tipoCodigo}`;

    // Mostrar estado de carregamento
    resultado.innerHTML = `
        <div class="loading">
            <div class="spinner"></div>
            <div class="searching-message">
                <p>üîç Buscando informa√ß√µes do produto...</p>
                <p class="searching-sources">C√≥digo: ${codigo} (${tipoCodigo})</p>
                <p class="searching-sources">Consultando fontes dispon√≠veis...</p>
            </div>
            <div class="barcode-formats">
                <small>Formatos alternativos:
                    ${['EAN-13', 'UPC-A', 'ISBN-13', 'ISBN-10'].map(fmt =>
                        `<a href="#" onclick="event.preventDefault(); converterEAtualizar('${codigo}', '${fmt}');">${fmt}</a>`
                    ).join(' | ')}
                </small>
            </div>
        </div>
    `;

    try {
        // Array de todas as fun√ß√µes de busca
        const searchFunctions = [
            searchOpenFoodFacts,
            searchUpcItemDb,
            searchGoogleShopping,
            searchWwWOpenProductData,
            searchUpcDatabase,
            searchGoogleShoppingScraper
        ];

        // Se for um ISBN, prioriza as APIs de livros
        if (tipoCodigo.includes('ISBN')) {
            searchFunctions.unshift(searchGoogleBooks);
            searchFunctions.unshift(searchOpenLibrary);
        }

        let productInfo = { found: false };
        let currentSearchIndex = 0;

        // Fun√ß√£o para tentar a pr√≥xima busca
        const tryNextSearch = async () => {
            if (currentSearchIndex >= searchFunctions.length) return false;

            const searchFunc = searchFunctions[currentSearchIndex];
            const sourceName = searchFunc.name.replace('search', '').replace(/([A-Z])/g, ' $1').trim();

            // Atualiza a mensagem mostrando qual fonte est√° sendo consultada
            const searchingElement = document.querySelector('.searching-sources');
            if (searchingElement) {
                searchingElement.textContent = `Consultando: ${sourceName}...`;
            }

            try {
                const result = await searchFunc(codigo);
                if (result.found) {
                    return result;
                }
            } catch (error) {
                console.error(`Erro na busca ${sourceName}:`, error);
            }

            currentSearchIndex++;
            return tryNextSearch();
        };

        // Inicia a cadeia de buscas
        productInfo = await tryNextSearch();

        if (productInfo.found) {
            resultado.innerHTML = formatProductInfo(productInfo);
        } else {
            resultado.innerHTML = `
                <div class='product-not-found'>
                    <p>‚ùå Produto n√£o encontrado nas bases de dados.</p>
                    <p>Voc√™ pode tentar pesquisar em outros sites:</p>
                    <ul>
                        <li><a href='https://www.google.com/search?q=${codigo}+barcode' target='_blank'>Pesquisar no Google</a></li>
                        <li><a href='https://www.barcodelookup.com/${codigo}' target='_blank'>Barcode Lookup</a></li>
                        <li><a href='https://www.upcitemdb.com/upc/${codigo}' target='_blank'>UPC ItemDB</a></li>
                        <li><a href='https://www.google.com/shopping/product/1?q=${codigo}' target='_blank'>Google Shopping</a></li>
                        <li><a href='https://barcodes.tec-it.com/pt/?barcode=${codigo}' target='_blank'>TEC-IT Barcode</a></li>
                    </ul>
                </div>
            `;
        }
    } catch (error) {
        console.error('Erro ao buscar produto:', error);
        resultado.innerHTML = `
            <div class='error'>
                <p>‚ö†Ô∏è Ocorreu um erro ao buscar o produto.</p>
                <p>Detalhes: ${error.message || 'Erro desconhecido'}</p>
                <p>Tente novamente mais tarde ou verifique sua conex√£o com a internet.</p>
            </div>
        `;
    }
}

async function searchOpenFoodFacts(barcode) {
    try {
        const response = await fetch(`https://world.openfoodfacts.org/api/v0/product/${barcode}.json`);
        const data = await response.json();

        if (data.status === 1) {
            const product = data.product;
            return {
                found: true,
                name: product.product_name || 'Produto n√£o identificado',
                brand: product.brands || 'Marca n√£o especificada',
                category: product.categories || 'Categoria n√£o especificada',
                image: product.image_url || '',
                details: {
                    quantidade: product.quantity || 'N√£o informado',
                    pa√≠ses: product.countries || 'N√£o informado',
                    ingredientes: product.ingredients_text || 'N√£o dispon√≠vel',
                    'c√≥digo de barras': barcode
                },
                source: 'Open Food Facts',
                barcode: barcode
            };
        }
    } catch (error) {
        console.error('Erro na API Open Food Facts:', error);
    }
    return { found: false };
}



// Fun√ß√£o de busca na API do UPC ItemDB via proxy
async function searchUpcItemDb(barcode) {
    try {
        const response = await fetch(`/api/upc-itemdb/${barcode}`);
        const data = await response.json();

        if (data.code === 'OK' && data.items && data.items.length > 0) {
            const item = data.items[0];
            return {
                found: true,
                name: item.title || 'Produto n√£o identificado',
                brand: item.brand || 'Marca n√£o especificada',
                category: item.category || 'Categoria n√£o especificada',
                image: item.images && item.images.length > 0 ? item.images[0] : '',
                details: {
                    descri√ß√£o: item.description || 'N√£o dispon√≠vel',
                    'c√≥digo de barras': barcode,
                    'pre√ßo m√©dio': item.lowest_recorded_price ? `$${item.lowest_recorded_price} - $${item.highest_recorded_price}` : 'N√£o dispon√≠vel',
                    'cor': item.color || 'N√£o especificado',
                    'dimens√µes': item.dimension || 'N√£o dispon√≠vel',
                    'peso': item.weight || 'N√£o dispon√≠vel'
                },
                source: 'UPC ItemDB',
                barcode: barcode
            };
        }
    } catch (error) {
        console.error('Erro na API UPC ItemDB:', error);
    }
    return { found: false };
}

// Fun√ß√£o de busca na API do Google Shopping (via RapidAPI)
async function searchGoogleShopping(barcode) {
    try {
        const options = {
            method: 'GET',
            headers: {
                'x-rapidapi-key': '497a68a614msh6e2d3b3f0609093p12ba49jsnfc0a5338235f', // Em produ√ß√£o, use uma vari√°vel de ambiente
                'x-rapidapi-host': 'google-data-scraper.p.rapidapi.com'
            },
            credentials: 'include'
        };

        const response = await fetch(`https://google-data-scraper.p.rapidapi.com/search/shop/${encodeURIComponent(barcode)}`, options);
        const data = await response.json();

        console.log('Resposta da API Google Shopping:', data); // Para depura√ß√£o

        // Verifica se a resposta tem a estrutura esperada
        if (data && data.shopping_results && data.shopping_results.length > 0) {
            const product = data.shopping_results[0];
            return {
                found: true,
                name: product.title || 'Produto n√£o identificado',
                brand: product.source || 'Marca n√£o especificada',
                category: product.extracted_category || 'Categoria n√£o especificada',
                image: product.thumbnail || '',
                details: {
                    pre√ßo: product.price_raw || 'N√£o dispon√≠vel',
                    loja: product.source || 'N√£o especificada',
                    avalia√ß√£o: product.rating ? `${product.rating}/5` : 'N√£o avaliado',
                    'c√≥digo de barras': barcode,
                    'link': product.link || ''
                },
                source: 'Google Shopping',
                barcode: barcode
            };
        }
    } catch (error) {
        console.error('Erro na API Google Shopping:', error);
    }
    return { found: false };
}

// Fun√ß√£o de busca na World Wide Open Product Database
async function searchWwWOpenProductData(barcode) {
    try {
        const response = await fetch(`https://world.openproductdata.com/api/v0/product/${barcode}.json`);
        const data = await response.json();

        if (data.status === 'success' && data.product) {
            const product = data.product;
            return {
                found: true,
                name: product.product_name || 'Produto n√£o identificado',
                brand: product.brands || 'Marca n√£o especificada',
                category: product.categories || 'Categoria n√£o especificada',
                image: product.image_url || '',
                details: {
                    quantidade: product.quantity || 'N√£o informado',
                    'pa√≠ses dispon√≠veis': product.countries || 'N√£o informado',
                    'c√≥digo de barras': barcode
                },
                source: 'World Wide Open Product Database',
                barcode: barcode
            };
        }
    } catch (error) {
        console.error('Erro na API World Wide Open Product Database:', error);
    }
    return { found: false };
}

// Fun√ß√£o de busca na API Google Shopping Scraper (via RapidAPI)
async function searchGoogleShoppingScraper(barcode) {
    try {
        const options = {
            method: 'GET',
            headers: {
                'x-rapidapi-key': '497a68a614msh6e2d3b3f0609093p12ba49jsnfc0a5338235f', // Em produ√ß√£o, use uma vari√°vel de ambiente
                'x-rapidapi-host': 'google-shopping-scraper2.p.rapidapi.com'
            },
            credentials: 'include'
        };

        const response = await fetch(`https://google-shopping-scraper2.p.rapidapi.com/products?q=${encodeURIComponent(barcode)}&country=br&language=pt-br`, options);
        const data = await response.json();

        console.log('Resposta da API Google Shopping Scraper:', data); // Para depura√ß√£o

        if (data.data && data.data.length > 0) {
            const product = data.data[0];
            return {
                found: true,
                name: product.title || 'Produto n√£o identificado',
                brand: product.brand || 'Marca n√£o especificada',
                category: product.category || 'Categoria n√£o especificada',
                image: product.image || '',
                details: {
                    pre√ßo: product.price ? `R$ ${product.price}` : 'Pre√ßo n√£o dispon√≠vel',
                    loja: product.seller || 'Loja n√£o especificada',
                    avalia√ß√£o: product.rating ? `${product.rating} estrelas` : 'N√£o avaliado',
                    'c√≥digo de barras': barcode,
                    'disponibilidade': product.availability || 'Disponibilidade n√£o informada',
                    'frete gr√°tis': product.free_shipping ? 'Sim' : 'N√£o'
                },
                source: 'Google Shopping Scraper',
                barcode: barcode,
                productUrl: product.url || ''
            };
        }
    } catch (error) {
        console.error('Erro na API Google Shopping Scraper:', error);
    }
    return { found: false };
}

// Fun√ß√£o de busca na API do Google Books
async function searchGoogleBooks(isbn) {
    try {
        const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`);
        const data = await response.json();

        if (data.totalItems > 0 && data.items && data.items.length > 0) {
            const book = data.items[0].volumeInfo;
            return {
                found: true,
                name: book.title || 'Livro n√£o identificado',
                brand: book.publisher || 'Editora n√£o especificada',
                category: book.categories ? book.categories.join(', ') : 'Livro',
                image: book.imageLinks ? book.imageLinks.thumbnail : '',
                details: {
                    autores: book.authors ? book.authors.join(', ') : 'Autor desconhecido',
                    'ano de publica√ß√£o': book.publishedDate || 'N√£o informado',
                    'n√∫mero de p√°ginas': book.pageCount ? `${book.pageCount} p√°ginas` : 'N√£o informado',
                    idioma: book.language ? book.language.toUpperCase() : 'N√£o informado',
                    'c√≥digo ISBN': isbn,
                    'descri√ß√£o': book.description ?
                        (book.description.length > 200 ?
                         book.description.substring(0, 200) + '...' :
                         book.description) :
                        'Descri√ß√£o n√£o dispon√≠vel'
                },
                source: 'Google Books',
                barcode: isbn
            };
        }
    } catch (error) {
        console.error('Erro na API Google Books:', error);
    }
    return { found: false };
}

// Fun√ß√£o de busca na Open Library
async function searchOpenLibrary(isbn) {
    try {
        const response = await fetch(`https://openlibrary.org/api/books?bibkeys=ISBN:${isbn}&format=json&jscmd=data`);
        const data = await response.json();
        const bookKey = `ISBN:${isbn}`;

        if (data[bookKey]) {
            const book = data[bookKey];
            return {
                found: true,
                name: book.title || 'Livro n√£o identificado',
                brand: book.publishers ? book.publishers.map(p => p.name).join(', ') : 'Editora n√£o especificada',
                category: book.subjects ? book.subjects.map(s => s.name).join(', ') : 'Livro',
                image: book.cover ? book.cover.medium || book.cover.large || '' : '',
                details: {
                    autores: book.authors ? book.authors.map(a => a.name).join(', ') : 'Autor desconhecido',
                    'ano de publica√ß√£o': book.publish_date || 'N√£o informado',
                    'n√∫mero de p√°ginas': book.number_of_pages ? `${book.number_of_pages} p√°ginas` : 'N√£o informado',
                    'c√≥digo ISBN': isbn,
                    'identificadores': book.identifiers ?
                        Object.entries(book.identifiers).map(([key, value]) =>
                            `${key}: ${value.join(', ')}`).join(' | ') :
                        'N√£o dispon√≠vel'
                },
                source: 'Open Library',
                barcode: isbn
            };
        }
    } catch (error) {
        console.error('Erro na API Open Library:', error);
    }
    return { found: false };
}

// Fun√ß√£o de busca na API do UPCDatabase.org
async function searchUpcDatabase(barcode) {
    try {
        const response = await fetch(`https://api.upcdatabase.org/product/${barcode}?apikey=${process.env.UPC_DATABASE_KEY}`);
        const data = await response.json();

        if (data.valid === true) {
            return {
                found: true,
                name: data.title || 'Produto n√£o identificado',
                brand: data.brand || 'Marca n√£o especificada',
                category: data.category || 'Categoria n√£o especificada',
                image: data.image || '',
                details: {
                    descri√ß√£o: data.description || 'N√£o dispon√≠vel',
                    'c√≥digo de barras': barcode,
                    'tamanho': data.size || 'N√£o especificado',
                    'cor': data.color || 'N√£o especificado',
                    'pre√ßo': data.msrp ? `$${data.msrp}` : 'N√£o dispon√≠vel'
                },
                source: 'UPC Database',
                barcode: barcode
            };
        }
    } catch (error) {
        console.error('Erro na API UPC Database:', error);
    }
    return { found: false };
}

function formatProductInfo(productInfo) {
    let detailsHtml = '';
    for (const [key, value] of Object.entries(productInfo.details)) {
        detailsHtml += `<p><strong>${key}:</strong> ${value}</p>`;
    }

    // Adiciona link para o produto se dispon√≠vel
    const productLink = productInfo.productUrl ?
        `<p class='product-link'><a href='${productInfo.productUrl}' target='_blank' class='btn'>Ver no Google Shopping ‚Üí</a></p>` : '';

    return `
        <div class='product-info'>
            <div class='product-header'>
                ${productInfo.image ? `<img src='${productInfo.image}' alt='${productInfo.name}' class='product-image' />` : ''}
                <div>
                    <h3>${productInfo.name}</h3>
                    <p><strong>Marca:</strong> ${productInfo.brand}</p>
                    <p><strong>Categoria:</strong> ${productInfo.category}</p>
                    <p><small>Fonte: ${productInfo.source}</small></p>
                    ${productLink}
                </div>
            </div>
            <div class='product-details'>
                ${detailsHtml}
            </div>
        </div>
    `;
}

function gerarCodigoPersonalizado() {
    let countryCode = document.getElementById("customCountrySelect").value;
    let productCode = document.getElementById("customProductCode").value.replace(/\D/g, "");
    if (productCode.length < 1 || productCode.length > 8) {
        alert("‚úèÔ∏è Insira um c√≥digo do produto com at√© 8 d√≠gitos.");
        return;
    }
    let base = countryCode + productCode.padStart(8, "0");
    let codigo12 = base.slice(0, 11) + "0"; // last digit before check digit set to 0
    let dv = calcularDigitoVerificador(codigo12);
    let codigoCompleto = codigo12 + dv;
    let resultado = document.getElementById("customCodeResult");
    resultado.textContent = "C√≥digo de Barras Gerado: " + codigoCompleto;
}

// Fun√ß√£o para filtrar a lista de pa√≠ses
function setupCountrySearch() {
    const searchInput = document.getElementById('countrySearch');
    const countrySelect = document.getElementById('countrySelect');
    const options = Array.from(countrySelect.options);

    // Armazena todas as op√ß√µes originais
    const originalOptions = options.map(option => ({
        value: option.value,
        text: option.text,
        element: option
    }));

    // Fun√ß√£o para filtrar as op√ß√µes
    function filterOptions(searchTerm) {
        const term = searchTerm.toLowerCase().trim();

        // Remove todas as op√ß√µes atuais
        while (countrySelect.options.length > 0) {
            countrySelect.remove(0);
        }

        // Filtra as op√ß√µes originais
        const filteredOptions = originalOptions.filter(option =>
            option.text.toLowerCase().includes(term) ||
            option.value.includes(term)
        );

        // Adiciona as op√ß√µes filtradas de volta ao select
        filteredOptions.forEach(option => {
            countrySelect.add(option.element);
        });

        // Se n√£o houver resultados, mostra uma mensagem
        if (filteredOptions.length === 0) {
            const noResults = document.createElement('option');
            noResults.value = '';
            noResults.textContent = 'Nenhum pa√≠s encontrado';
            noResults.disabled = true;
            countrySelect.add(noResults);
        }
    }

    // Adiciona o evento de input para a busca
    searchInput.addEventListener('input', (e) => {
        filterOptions(e.target.value);
    });

    // Adiciona foco ao campo de busca quando a p√°gina carrega
    searchInput.focus();
}

// Inicializa a busca de pa√≠ses quando o DOM estiver pronto
document.addEventListener('DOMContentLoaded', setupCountrySearch);

// Barcode scanner using QuaggaJS
let scannerRunning = false;
let lastScannedCode = '';
let lastScanTime = 0;

function iniciarScanner() {
    if (scannerRunning) {
        return;
    }

    // Limpar resultados anteriores e adicionar container para o scanner
    const scannerContainer = document.getElementById('scannerContainer');
    scannerContainer.innerHTML = `
        <div id="interactive" class="viewport">
            <div class="overlay">
                <div class="scanline"></div>
            </div>
            <div class="detection-info">Aponte para um c√≥digo de barras</div>
        </div>
    `;

    document.getElementById("scannerResult").innerHTML = "<p>Iniciando c√¢mera... Por favor, permita o acesso √† c√¢mera quando solicitado.</p>";
    scannerRunning = true;

    // Configura√ß√£o do QuaggaJS
    Quagga.init({
        inputStream: {
            name: "Live",
            type: "LiveStream",
            target: document.querySelector('#interactive'),
            constraints: {
                width: { ideal: 1280 },
                height: { ideal: 720 },
                aspectRatio: 4/3,
                facingMode: "environment"
            },
            area: {
                top: "0%",
                right: "0%",
                left: "0%",
                bottom: "0%"
            }
        },
        decoder: {
            readers: ["ean_reader", "ean_8_reader", "code_128_reader", "code_39_reader", "code_39_vin_reader", "codabar_reader", "upc_reader", "upc_e_reader"]
        },
        locator: {
            halfSample: true,
            patchSize: "medium",
            debug: {
                showCanvas: false,
                showPatches: false,
                showFoundPatches: false,
                showSkeleton: false,
                showLabels: false,
                showPatchLabels: false,
                showRemainingPatchLabels: false,
                boxFromPatches: {
                    showTransformed: false,
                    showTransformedBox: false,
                    showBB: false
                }
            }
        },
        frequency: 10,
        debug: false,
        multiple: false
    }, function (err) {
        if (err) {
            console.error("Erro ao inicializar o scanner:", err);
            document.querySelector('.detection-info').textContent = 'Erro ao acessar a c√¢mera';
            return;
        }

        // Configura o desenho do ret√¢ngulo de detec√ß√£o
        Quagga.onProcessed(function(result) {
            try {
                const drawingCtx = Quagga.canvas.ctx.overlay;
                const drawingCanvas = Quagga.canvas.dom.overlay;

                if (drawingCtx && drawingCanvas) {
                    drawingCtx.clearRect(0, 0, parseInt(drawingCanvas.width), parseInt(drawingCanvas.height));

                    if (result) {
                        if (result.boxes) {
                            result.boxes.filter(function(box) {
                                return box !== result.box;
                            }).forEach(function(box) {
                                Quagga.ImageDebug.drawPath(box, {x: 0, y: 1}, drawingCtx, {color: "green", lineWidth: 2});
                            });
                        }

                        if (result.box) {
                            Quagga.ImageDebug.drawPath(result.box, {x: 0, y: 1}, drawingCtx, {color: "#00F", lineWidth: 2});
                        }

                        if (result.codeResult && result.codeResult.code) {
                            Quagga.ImageDebug.drawPath(result.line, {x: 'x', y: 'y'}, drawingCtx, {color: 'red', lineWidth: 3});
                        }
                    }
                }
            } catch (e) {
                console.error("Erro ao processar frame:", e);
            }
        });

        Quagga.start().then(() => {
            // Atualizar a interface quando a c√¢mera estiver pronta
            const scannerContainer = document.getElementById('scannerContainer');
            if (scannerContainer) {
                scannerContainer.innerHTML = `
                    <div id="interactive" class="viewport">
                        <p style="color: white; text-align: center; margin-top: 20px;">
                            Aponte para um c√≥digo de barras
                        </p>
                    </div>
                `;
            }
            document.getElementById("scannerResult").innerHTML = "<p>Scanner ativo. Aponte para um c√≥digo de barras.</p>";
        }).catch(err => {
            console.error("Erro ao iniciar o scanner:", err);
            document.getElementById("scannerResult").innerHTML = "<p>Erro ao acessar a c√¢mera. Por favor, verifique as permiss√µes e tente novamente.</p>";
            scannerRunning = false;
        });
    });

    // Quando um c√≥digo for detectado
    Quagga.onDetected(function(result) {
        const code = result.codeResult.code;
        const now = new Date().getTime();

        // Evitar leituras duplicadas muito pr√≥ximas no tempo (500ms)
        if (code === lastScannedCode && (now - lastScanTime < 500)) {
            return;
        }

        lastScannedCode = code;
        lastScanTime = now;

        // Atualizar o campo de busca e pesquisar
        const searchInput = document.getElementById("searchBarcode");
        if (searchInput) {
            searchInput.value = code;
            // Disparar o evento de input para atualizar a interface
            searchInput.dispatchEvent(new Event('input'));

            // Atualizar feedback visual
            const scannerContainer = document.getElementById('scannerContainer');
            if (scannerContainer) {
                scannerContainer.innerHTML = `
                    <div style="color: white; text-align: center; padding: 20px;">
                        <h3>C√≥digo detectado:</h3>
                        <div style="font-size: 1.5em; margin: 10px 0; font-weight: bold;">${code}</div>
                        <p>Pesquisando informa√ß√µes...</p>
                    </div>
                `;
            }

            // Pesquisar automaticamente ap√≥s um pequeno atraso
            setTimeout(() => {
                buscarProduto();
            }, 300);
        }
    });
}

function pararScanner() {
    if (scannerRunning) {
        try {
            Quagga.stop();
            const scannerContainer = document.getElementById('scannerContainer');
            if (scannerContainer) {
                scannerContainer.innerHTML = `
                    <div style="color: white; text-align: center; padding: 20px;">
                        <p>Scanner desativado. Clique em "Iniciar Scanner" para ativar novamente.</p>
                    </div>
                `;
            }
            document.getElementById("scannerResult").innerHTML = "<p>Scanner desativado.</p>";
        } catch (error) {
            console.error("Erro ao parar o scanner:", error);
            document.getElementById("scannerResult").innerHTML = "<p>Ocorreu um erro ao desativar o scanner.</p>";
        } finally {
            scannerRunning = false;
        }
    }
}